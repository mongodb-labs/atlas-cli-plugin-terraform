package hcl

import (
	"fmt"
	"strconv"

	"github.com/hashicorp/hcl/v2"
	"github.com/hashicorp/hcl/v2/hclsyntax"
	"github.com/hashicorp/hcl/v2/hclwrite"
	"github.com/zclconf/go-cty/cty"
)

const (
	resourceType                = "resource"
	cluster                     = "mongodbatlas_cluster"
	advCluster                  = "mongodbatlas_advanced_cluster"
	strReplicationSpecs         = "replication_specs"
	strRegionConfigs            = "region_configs"
	strElectableSpecs           = "electable_specs"
	strProviderRegionName       = "provider_region_name"
	strRegionName               = "region_name"
	strProviderName             = "provider_name"
	strBackingProviderName      = "backing_provider_name"
	strProviderInstanceSizeName = "provider_instance_size_name"
	strInstanceSize             = "instance_size"

	errFreeCluster = "free cluster (as doesn't contain " + strReplicationSpecs + ")"
)

// ClusterToAdvancedCluster transforms all mongodbatlas_cluster definitions in a
// Terraform configuration file into mongodbatlas_advanced_cluster schema v2 definitions.
// All other resources and data sources are left untouched.
// TODO: at the moment it just changes the resource type.
func ClusterToAdvancedCluster(config []byte) ([]byte, error) {
	parser, err := getParser(config)
	if err != nil {
		return nil, err
	}
	for _, resource := range parser.Body().Blocks() {
		labels := resource.Labels()
		resourceName := labels[0]
		if resource.Type() != resourceType || resourceName != cluster {
			continue
		}
		resourceBody := resource.Body()

		// TODO: Do the full transformation
		labels[0] = advCluster
		resource.SetLabels(labels)

		if resourceBody.FirstMatchingBlock(strReplicationSpecs, nil) == nil {
			if err := fillFreeTier(resourceBody); err != nil {
				return nil, err
			}
		}

		resourceBody.AppendNewline()
		appendComment(resourceBody, "Generated by atlas-cli-plugin-terraform.")
		appendComment(resourceBody, "Please confirm that all references to this resource are updated.")
	}
	return parser.Bytes(), nil
}

func fillFreeTier(resourceBody *hclwrite.Body) error {
	resourceBody.SetAttributeValue("cluster_type", cty.StringVal("REPLICASET"))

	regionConfig := hclwrite.NewEmptyFile()
	regionConfigBody := regionConfig.Body()
	setAttrInt(regionConfig.Body(), "priority", 7)
	if err := moveAttribute(strProviderRegionName, strRegionName, resourceBody, regionConfigBody, errFreeCluster); err != nil {
		return err
	}
	if err := moveAttribute(strProviderName, strProviderName, resourceBody, regionConfigBody, errFreeCluster); err != nil {
		return err
	}
	if err := moveAttribute(strBackingProviderName, strBackingProviderName, resourceBody, regionConfigBody, errFreeCluster); err != nil {
		return err
	}

	electableSpec := hclwrite.NewEmptyFile()
	if err := moveAttribute(strProviderInstanceSizeName, strInstanceSize, resourceBody, electableSpec.Body(), errFreeCluster); err != nil {
		return err
	}
	regionConfig.Body().SetAttributeRaw(strElectableSpecs, objectTokens(electableSpec))

	replicationSpec := hclwrite.NewEmptyFile()
	replicationSpec.Body().SetAttributeRaw(strRegionConfigs, singleArrayTokens(regionConfig))

	resourceBody.SetAttributeRaw(strReplicationSpecs, singleArrayTokens(replicationSpec))
	return nil
}

func moveAttribute(fromAttrName, toAttrName string, fromBody, toBody *hclwrite.Body, errPrefix string) error {
	attr := fromBody.GetAttribute(fromAttrName)
	if attr == nil {
		return fmt.Errorf("%s: attribute %s not found", errPrefix, fromAttrName)
	}
	fromBody.RemoveAttribute(fromAttrName)
	toBody.SetAttributeRaw(toAttrName, attr.Expr().BuildTokens(nil))
	return nil
}

func setAttrInt(body *hclwrite.Body, attrName string, number int) {
	tokens := hclwrite.Tokens{
		{Type: hclsyntax.TokenNumberLit, Bytes: []byte(strconv.Itoa(number))},
	}
	body.SetAttributeRaw(attrName, tokens)
}

func singleArrayTokens(file *hclwrite.File) hclwrite.Tokens {
	ret := hclwrite.Tokens{
		{Type: hclsyntax.TokenOBrack, Bytes: []byte("[")},
		{Type: hclsyntax.TokenOBrack, Bytes: []byte("{")},
		{Type: hclsyntax.TokenNewline, Bytes: []byte("\n")},
	}
	ret = append(ret, file.BuildTokens(nil)...)
	ret = append(ret,
		&hclwrite.Token{Type: hclsyntax.TokenCBrack, Bytes: []byte("}")},
		&hclwrite.Token{Type: hclsyntax.TokenCBrack, Bytes: []byte("]")})
	return ret
}

func objectTokens(file *hclwrite.File) hclwrite.Tokens {
	ret := hclwrite.Tokens{
		{Type: hclsyntax.TokenOBrack, Bytes: []byte("{")},
		{Type: hclsyntax.TokenNewline, Bytes: []byte("\n")},
	}
	ret = append(ret, file.BuildTokens(nil)...)
	ret = append(ret,
		&hclwrite.Token{Type: hclsyntax.TokenCBrack, Bytes: []byte("}")})
	return ret
}

func getParser(config []byte) (*hclwrite.File, error) {
	parser, diags := hclwrite.ParseConfig(config, "", hcl.Pos{Line: 1, Column: 1})
	if diags.HasErrors() {
		return nil, fmt.Errorf("failed to parse Terraform config file: %s", diags.Error())
	}
	return parser, nil
}

func appendComment(body *hclwrite.Body, comment string) {
	tokens := hclwrite.Tokens{
		&hclwrite.Token{
			Type:  hclsyntax.TokenComment,
			Bytes: []byte("# " + comment + "\n"),
		},
	}
	body.AppendUnstructuredTokens(tokens)
}
